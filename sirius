from collections import deque
import sys

def read_grid():
    data = sys.stdin.read().strip().splitlines()
    M, N = map(int, data[0].strip().split())
    grid = []
    for i in range(1, M + 1):
        line = data[i].strip()
        parts = line.split()
        if len(parts) == N:
            row = parts
        else:
            row = list(line.replace(" ", ""))
        grid.append(row)
    return M, N, grid

def solve():
    M, N, grid = read_grid()

    start, target = [], []
    for i in range(M):
        for j in range(N):
            if grid[i][j] == 's':
                start.append((i, j))
            elif grid[i][j] == 'S':
                target.append((i, j))

    def orient(cells): return 'H' if cells[0][0] == cells[1][0] else 'V'
    def normalize(cells, o):
        if o == 'H': return (cells[0][0], min(c[1] for c in cells), 'H')
        else: return (min(c[0] for c in cells), cells[0][1], 'V')

    start_state = normalize(start, orient(start))
    target_state = normalize(target, orient(target))

    def free(x, y): return 0 <= x < M and 0 <= y < N and grid[x][y] != 'H'
    def block_free(cells): return all(free(x, y) for x, y in cells)

    def neighbors(x, y, o):
        nxt = []
        if o == 'H':
            if y - 1 >= 0 and free(x, y - 1): nxt.append((x, y - 1, 'H'))
            if y + 2 < N and free(x, y + 2): nxt.append((x, y + 1, 'H'))
            if x - 1 >= 0 and free(x - 1, y) and free(x - 1, y + 1): nxt.append((x - 1, y, 'H'))
            if x + 1 < M and free(x + 1, y) and free(x + 1, y + 1): nxt.append((x + 1, y, 'H'))
            if x - 1 >= 0 and y + 1 < N and block_free([(x - 1, y), (x - 1, y + 1), (x, y), (x, y + 1)]):
                nxt.append((x - 1, y, 'V')); nxt.append((x - 1, y + 1, 'V'))
            if x + 1 < M and y + 1 < N and block_free([(x, y), (x, y + 1), (x + 1, y), (x + 1, y + 1)]):
                nxt.append((x, y, 'V')); nxt.append((x, y + 1, 'V'))
        else:
            if x - 1 >= 0 and free(x - 1, y): nxt.append((x - 1, y, 'V'))
            if x + 2 < M and free(x + 2, y): nxt.append((x + 1, y, 'V'))
            if y - 1 >= 0 and free(x, y - 1) and free(x + 1, y - 1): nxt.append((x, y - 1, 'V'))
            if y + 1 < N and free(x, y + 1) and free(x + 1, y + 1): nxt.append((x, y + 1, 'V'))
            if y - 1 >= 0 and block_free([(x, y - 1), (x, y), (x + 1, y - 1), (x + 1, y)]):
                nxt.append((x, y - 1, 'H')); nxt.append((x + 1, y - 1, 'H'))
            if y + 1 < N and block_free([(x, y), (x, y + 1), (x + 1, y), (x + 1, y + 1)]):
                nxt.append((x, y, 'H')); nxt.append((x + 1, y, 'H'))
        return nxt

    dq = deque([(start_state, 0)])
    seen = {start_state}
    while dq:
        (cx, cy, co), d = dq.popleft()
        if (cx, cy, co) == target_state:
            print(d, end="")  # ensure no extra newline
            return
        for s in neighbors(cx, cy, co):
            if s not in seen:
                seen.add(s)
                dq.append((s, d + 1))
    print("Impossible", end="")

if __name__ == "__main__":
    solve()


